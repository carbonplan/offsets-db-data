---
jupytext:
  text_representation:
    format_name: myst
kernelspec:
  display_name: Python 3
  name: python3
---

# Order of Operations

OffsetsDB follows a typical extract-transform-load (ETL) workflow.
Extraction involves querying and downloading raw credit and project data hosted by offset registries.
Transformation involves executing the functions contained within this repo, `offsets-db-data`.
Load involves uploading the resulting data to S3 and the Postgres-backend that powers the OffsetsDB web tool.

## Downloading raw data

We download a fresh copy of project and transaction data on a daily basis.
While downloading, we make no changes to the raw data provided by the registries.
All data are permanently archived and are made immediately available for download in a publicly available S3 bucket (see [Data Access](data-access.md)).

We have no plans to release the code the directly interacts with registries.
We decided to keep this part of OffsetsDB private in an effort to limit download requests from the registries.
Other, technical aspects of OffsetsDB, like the database and API that power the [web tool](TK) are similarly closed.
We made this decision to ensure that the OffsetsDB web tool remains performant.
Critically, the production database represents an identical clone of the data generated by the code contained within `offsets-db-data` (TK this is true?).
No additional processing or inferences occur outside the context of this repository.

## Transforming raw data

Nearly the entirety of the code contained within `offsets-db-data` involves registry-specific logic for transforming raw registry data into a common, shared schema.
The logic for transforming the data of each registry is contained within a single file, with the filename denoting which registry the transformations apply to.
For example, the logic involved in transforming Verra data are contained within `vcs.py`.

Each registry-specific file contains at least two functions: `process_{registry_abbreviation}_credits` and `process_{registry_abbreviation}_projects`
Those functions, in turn, call a series of additional transformation functions that produce the normalized project and credit data which combine to form OffsetsDB.
These transformation functions tend to be quite small and operate on one or two properties of the raw data.
To continue with the Verra example, `vcs.py` contains functions with names like `set_vcs_vintage_year` and `generate_vcs_project_ids`.
These functions contain the registry-specific logic needed to map Verra's raw data to the common data schema of OffsetsDB.

### An example

In practice, replicating the behavior of OffsetsDB should be simple.
Here's an example of using `offsets_db_data` to transform the raw transactions data from Verra into a normalized, analysis ready file:

```{code-cell} ipython3
import pandas as pd
from offsets_db_data import vcs

archive_fname = 's3://carbonplan-offsets-db/raw/2023-12-05/verra/transactions.csv.gz'
raw_credits =  pd.read_csv(archive_fname)
processed_credits =  vcs.process_vcs_credits(raw_credits)
```

Invoking single transformation functions, like `set_vcs_vintage_year` is even more straightforward.
Let's say you want to understand more about how OffsetsDB assigns Verra credits a vintage year.
You can explore the behavior of this single transformation function by calling:

```{code-cell} ipython3
raw_credits.set_vcs_vintage_year(date_column='Vintage End').head()
```

It's worth noting that we've wrapped all transformation functions using the `pandas_flavor.register_dataframe_method` decorator.
That means that after importing a registry module from `offsets_db_data`, the transformation functions of that module are directly callable by any Pandas dataframe.

## Initial Column Mapping

The initial and perhaps must mundane transformation of OffsetsDB involves mapping properties in the raw data to a common schema.
This step requires constructing a map between the names of properties as they appear in the raw data to the property in OffsetsDB.
For example, the Climate Action Reserve data refers to the property, `project_id`, as `Project ID`.
The ART registry, however, refers to the same property as `Program ID`.

These column mapping files are stored in `offsets_db_data/configs`.
There is a separate mapping file for `projects` data and `credits` data.
Some properties either aren't included in the raw data or inferring their value requires special processing.
In these cases, a `null` value is recorded in the column mapping files and the property is populated using registry-specific logic.

## Protocol Mapping \& Categorization

Offset projects are developed by following a set of rules, known as a protocol.
These rules specify things like when measurements must be made and what paperwork must be submitted in order for a project to receive credits.
Unfortunately, there is no standardized way of referring to the exact protocol (or protocol version) used to develop an offset project.
Even within the domain of a single registry, references to the exact protocol used to develop a project are often inconsistent.
Take for example the Clean Development Mechanism protocol AMS-III.D., "Methane recovery in animal manure management systems".
Across all six registries included in OffsetsDB, we identified twenty-two unique ways of referring to this one protocol.

OffsetsDB addresses this problem by manually assigning every known protocol string to a common schema.
Continuing with the AMS-III.D. example, we map all twenty-two "known strings" that describe the same protocol to a single, unified reference, `ams-iii-d`.
We repeat this manual unification of dissimilar strings for all protocols across all registries.
The results of the mapping are contained within `offsets-db-data/configs/all-protocol-mapping.json`

We also categorize each of these unified protocol references.
Those categories include:

- agriculture: offsets derived from the management of farmlands
- cookstoves: offsets derived from in-home cookstoves that are either more efficient or use cleaner fuels
- forest: offsets derived from the management of forests
- ghg-management: offsets derived from the destruction or elimination of greenhouse gases
- land-use: offsets derived from changes in land-use (e.g., avoided conversion)
- renewable-energy: offsets derived from expanding renewable energy capacity

Several other categories (and sub-categories) exist within the data.
We plan to further refine and sub-divide protocol (and project) categories in the future.

## Registry specific transformations

Some transformations involved in producing OffsetsDB require special knowledge or assumptions about the underlying data.
This section highlights special cases.
For additional context, consult specific function docstrings or [reach out on GitHub](https://github.com/carbonplan/offsets-db-data/issues) if something doesn't make sense.

### American Carbon Registry

Project status: When processing ACR projects, we combine two status properties present in the raw data: `Compliance Program Status (ARB or Ecology)` and `Voluntary Status`.
For compliance projects, we report compliance program status.
For voluntary projects, we report voluntary status.

### Verra

Issuance: Verra allows "rolling" credit issuance.
This allows projects to complete the paperwork and verificaiton processes for credit issuance, but delay the actual issuance event.
This results in ambiguities around the precise timing of credit issuance events, as credits that are eligible to be issued but have not yet been issued, are not publicly reported in the Verra crediting data.
We handle this ambiguity by assuming that the first crediting event, be it an issuance, retirement, or cancellation, on a per-project, per-vintage basis results in issuance of 100 percent of credits eligible to be issued for that project-vintage.

Retirements vs. Cancellations: Verra's publicly available data does not distinguish between retirement events and cancellation events.
We report all Verra retirements and cancellations as `retirement`.
We originally contemplated tagging every Verra retirement or cancellation as `retirement/cancellation`.
This made our processed Verra data slightly incompatiable with data from other registries.
Simple queries, like "give me all the retirements", suddenly required writing code that look like this:

```python
credits[(credits['transaction_type'] == 'retirement') | (credits['transaction_type'] == 'retirement/cancellation')]
```

Because we know the majority of Verra `retirement/cancellation` events are in fact `retirement`, we opted for this more ergonomic representation of the data.
Any analysis involving Verra retirement data should clearly specify that Verra's raw data does not currently distinguish between retirement and cancellation events.

Vintage Date: Verra allows for the simultaneous issuance of multiple vintages.
We assign all credits from these multi-vintage issuances to the earliest reported vintage year.

### California Compliance Projects

We treat the California Air Resources Board's [issuance table](https://ww2.arb.ca.gov/resources/documents/arb-offset-credit-issuance-table) as the source of truth for all credits issued and retired by any project developed under an ARB-approved protocol.
When a project appears in the issuance table, we drop all crediting data reported from the project's host registry and _only_ report the issuance and retirement values contained within the ARB issuance table.

Retirement Dates: Offsets retired for compliance with California's cap-and-trade program occur on fixed dates that correspond with the program's reporting deadlines.
These deadlines come in two forms: partial (annual) and full (triennial) compliance events.
For simplicity, the current version of OffsetsDB uses the date of the full (triennial) compliance event as the retirement date for all compliance offsets.
This means some retirement dates go unrecorded.
Specifically, compliance credits retired for _voluntary_ purposes (i.e., not to satisfy requirements under AB32) and credits retired in linked markets (e.g., Quebec) are unknown and reported as `NaT`.

## Other normalizations

### Country

We use the Python package [coutnry_convertor](https://github.com/IndEcol/country_converter) to harmonize country names.

### Project Status

OffsetsDB unifies and simplifies project status information reported by the registries.
OffsetsDB contains use the following status codes: `listed`, `registered`, and `completed`.
Listed typically refers to the stage during which a project has been formally announced and is undergoing development, but has yet to receive credits.
Registered refers to projects that have received credits and are eligible to receive additional credits in the future.
Completed means a project previously received credits and is not currently able to receive additional credits in the future.
Many registries have far more detailed project status information, often reflecting the specific stages of the registry's validation and verification process.

## Schema

### Projects

Project data conform to the following schema:

```json
{
  "title": "Project",
  "properties": {
    "project_id": {
      "title": "Project Id",
      "description": "Project id used by registry system",
      "type": "string"
    },
    "name": {
      "title": "Name",
      "description": "Name of the project",
      "type": "string"
    },
    "registry": {
      "title": "Registry",
      "description": "Name of the registry",
      "type": "string"
    },
    "proponent": { "title": "Proponent", "type": "string" },
    "protocol": {
      "title": "Protocol",
      "description": "List of protocols",
      "type": "array",
      "items": { "type": "string" }
    },
    "category": {
      "title": "Category",
      "description": "List of categories",
      "type": "array",
      "items": { "type": "string" }
    },
    "status": { "title": "Status", "type": "string" },
    "country": { "title": "Country", "type": "string" },
    "listed_at": {
      "title": "Listed At",
      "description": "Date project was listed",
      "type": "string",
      "format": "date"
    },
    "is_compliance": {
      "title": "Is Compliance",
      "description": "Whether project is compliance project",
      "type": "boolean"
    },
    "retired": {
      "title": "Retired",
      "description": "Total of retired credits",
      "type": "integer"
    },
    "issued": {
      "title": "Issued",
      "description": "Total of issued credits",
      "type": "integer"
    },
    "project_url": {
      "title": "Project Url",
      "description": "URL to project details",
      "type": "string"
    }
  }
}
```

The majority of project attributes are directly taken from the project data downloaded from each registry.
Table 1 provides the mapping from the raw column names found in downloaded registry data to the OffsetsDB project schema.

|                         | **verra**              | **climate-action-reserve** | **american-carbon-registry**           | **global-carbon-council**     | **gold-standard**      | **art-trees**               |
| ----------------------- | ---------------------- | -------------------------- | -------------------------------------- | ----------------------------- | ---------------------- | --------------------------- |
| **project_id**          | ID                     | Project ID                 | Project ID                             | project_submission_number     | id                     | Program ID                  |
| **name**                | Name                   | Project Name               | Project Name                           | project_url                   | name                   | Program Name                |
| **protocol**            | Methodology            | Project Type               | Project Methodology/Protocol           | project_methodology           | methodology            | \-                          |
| **category**            | inferred from protocol | inferred from protocol     | inferred from protocol                 | inferred from protocol        | inferred from protocol | inferred from protocol      |
| **project_subcategory** | manually assigned      | manually assigned          | manually assigned                      | manually assigned             | manually assigned      | manually assigned           |
| **proponent**           | Proponent              | Project Owner              | Project Developer                      | project_details:project_owner | project_developer      | Sovereign Program Developer |
| **country**             | Country/Area           | Project Site Country       | Project Site Country                   | project_country               | country                | Program Country             |
| **status**              | Status                 | Status                     | Derived: voluntary + compliance status | project_status                | status                 | Status                      |
| **listed_at**           | Project Listed Date    | \-                         | \-                                     | \-                            | \-                     | \-                          |

### Credits

Credit data conform to the following schema:

```json
{
  "title": "Credit",
  "properties": {
    "id": {
      "title": "Id",
      "type": "integer"
    },
    "project_id": {
      "title": "Project ID",
      "description": "Unique project identifier, by registry",
      "type": "string"
    },
    "quantity": {
      "title": "Quantity",
      "description": "Number of credits",
      "type": "integer"
    },
    "vintage": {
      "title": "Vintage",
      "description": "Vintage year of credits",
      "type": "integer"
    },
    "transaction_date": {
      "title": "Transaction Date",
      "description": "Date of transaction",
      "type": "string",
      "format": "date"
    },
    "transaction_type": {
      "title": "Transaction Type",
      "description": "Type of transaction (i.e., issuance, retirement)",
      "type": "string"
    }
  }
}
```

The majority of credit attributes are taken directly taken from the credit data downloaded from each registry.
The raw attribute names of crediting data tends to vary depending on the transaction type.
For example, ART TREES refers to retirement dates as `Status Effective`, while it reports issuances as `Date Approved`.
Rather than produce a table of each of these mappings here, please refer to [credits-raw-columns-mappings.json](TK).
